{"ast":null,"code":"var _jsxFileName = \"/Users/dongbingfeng/code/cursor_learn/nail-segmentation/frontend/src/contexts/ImageNavigationContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport { imageService } from '../services/imageService';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ImageNavigationContext = /*#__PURE__*/createContext(undefined);\nexport const ImageNavigationProvider = ({\n  children\n}) => {\n  _s();\n  const [images, setImages] = useState([]);\n  const [currentImageIndex, setCurrentImageIndex] = useState(0);\n  const [currentImageData, setCurrentImageData] = useState(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState(null);\n  const [progress, setProgress] = useState(null);\n  const [annotations, setAnnotations] = useState([]);\n  const currentImage = images[currentImageIndex] || null;\n\n  // Initialize: Load image list and progress\n  useEffect(() => {\n    initializeImageNavigation();\n  }, []);\n\n  // Load annotations when current image changes\n  useEffect(() => {\n    if (currentImage) {\n      loadCurrentImageData();\n    }\n  }, [currentImage]);\n  const initializeImageNavigation = async () => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Load image list\n      const imageList = await imageService.fetchImageList();\n      setImages(imageList);\n\n      // Load progress to determine starting index\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n      const startIndex = Math.min(progressData.currentImageIndex, Math.max(0, imageList.length - 1));\n      setCurrentImageIndex(startIndex);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to initialize image navigation');\n      console.error('Error initializing image navigation:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const loadCurrentImageData = async () => {\n    if (!currentImage) {\n      setCurrentImageData(null);\n      setAnnotations([]);\n      return;\n    }\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Load annotations for current image\n      const imageAnnotations = await imageService.fetchImageAnnotations(currentImage.id);\n      setAnnotations(imageAnnotations);\n\n      // Create ImageData object for compatibility with existing components\n      const imageData = {\n        id: currentImage.id,\n        filename: currentImage.filename,\n        url: currentImage.url,\n        width: currentImage.width,\n        height: currentImage.height,\n        annotations: imageAnnotations,\n        uploadedAt: currentImage.lastModified\n      };\n      setCurrentImageData(imageData);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load image data');\n      console.error('Error loading image data:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  const navigateNext = async () => {\n    if (currentImageIndex < images.length - 1) {\n      await navigateToIndex(currentImageIndex + 1);\n    }\n  };\n  const navigatePrevious = async () => {\n    if (currentImageIndex > 0) {\n      await navigateToIndex(currentImageIndex - 1);\n    }\n  };\n  const navigateToIndex = async index => {\n    if (index < 0 || index >= images.length) {\n      return;\n    }\n\n    // Save current annotations before navigation\n    if (currentImage && annotations.length > 0) {\n      await saveCurrentAnnotations(annotations);\n    }\n\n    // Update progress index on backend\n    try {\n      await imageService.updateProgressIndex(index);\n    } catch (err) {\n      console.warn('Failed to update progress index:', err);\n    }\n    setCurrentImageIndex(index);\n\n    // Refresh progress data\n    try {\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n    } catch (err) {\n      console.warn('Failed to refresh progress:', err);\n    }\n  };\n  const markImageComplete = async imageId => {\n    try {\n      // Update the image's completion status locally\n      setImages(prevImages => prevImages.map(img => img.id === imageId ? {\n        ...img,\n        isCompleted: true,\n        annotationCount: annotations.length\n      } : img));\n\n      // Refresh progress data\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n    } catch (err) {\n      console.error('Error marking image complete:', err);\n    }\n  };\n  const saveCurrentAnnotations = async annotationsToSave => {\n    if (!currentImage) return;\n    try {\n      await imageService.saveImageAnnotations(currentImage.id, annotationsToSave);\n\n      // Update local state\n      setAnnotations(annotationsToSave);\n\n      // Mark image as complete if it has annotations\n      if (annotationsToSave.length > 0) {\n        await markImageComplete(currentImage.id);\n      }\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save annotations');\n      console.error('Error saving annotations:', err);\n    }\n  };\n  const updateAnnotations = newAnnotations => {\n    setAnnotations(newAnnotations);\n  };\n  const refreshImageList = async () => {\n    try {\n      const imageList = await imageService.fetchImageList();\n      setImages(imageList);\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to refresh image list');\n    }\n  };\n  const contextValue = {\n    images,\n    currentImageIndex,\n    currentImage,\n    currentImageData,\n    isLoading,\n    error,\n    progress,\n    annotations,\n    navigateNext,\n    navigatePrevious,\n    navigateToIndex,\n    markImageComplete,\n    saveCurrentAnnotations,\n    updateAnnotations,\n    refreshImageList\n  };\n  return /*#__PURE__*/_jsxDEV(ImageNavigationContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 245,\n    columnNumber: 5\n  }, this);\n};\n_s(ImageNavigationProvider, \"JmN0m0VUq7SiIs/J7uz55n8m6lg=\");\n_c = ImageNavigationProvider;\nexport const useImageNavigation = () => {\n  _s2();\n  const context = useContext(ImageNavigationContext);\n  if (context === undefined) {\n    throw new Error('useImageNavigation must be used within an ImageNavigationProvider');\n  }\n  return context;\n};\n_s2(useImageNavigation, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default ImageNavigationContext;\nvar _c;\n$RefreshReg$(_c, \"ImageNavigationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","imageService","jsxDEV","_jsxDEV","ImageNavigationContext","undefined","ImageNavigationProvider","children","_s","images","setImages","currentImageIndex","setCurrentImageIndex","currentImageData","setCurrentImageData","isLoading","setIsLoading","error","setError","progress","setProgress","annotations","setAnnotations","currentImage","initializeImageNavigation","loadCurrentImageData","imageList","fetchImageList","progressData","fetchLabelingProgress","startIndex","Math","min","max","length","err","Error","message","console","imageAnnotations","fetchImageAnnotations","id","imageData","filename","url","width","height","uploadedAt","lastModified","navigateNext","navigateToIndex","navigatePrevious","index","saveCurrentAnnotations","updateProgressIndex","warn","markImageComplete","imageId","prevImages","map","img","isCompleted","annotationCount","annotationsToSave","saveImageAnnotations","updateAnnotations","newAnnotations","refreshImageList","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useImageNavigation","_s2","context","$RefreshReg$"],"sources":["/Users/dongbingfeng/code/cursor_learn/nail-segmentation/frontend/src/contexts/ImageNavigationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';\nimport { ImageData, Annotation } from '../types/annotations';\nimport { imageService } from '../services/imageService';\n\ninterface ImageMetadata {\n  id: string;\n  filename: string;\n  url: string;\n  width: number;\n  height: number;\n  isCompleted: boolean;\n  annotationCount: number;\n  lastModified: string;\n}\n\ninterface ProgressStatus {\n  totalImages: number;\n  completedImages: number;\n  currentImageIndex: number;\n  percentComplete: number;\n}\n\ninterface ImageNavigationContextType {\n  images: ImageMetadata[];\n  currentImageIndex: number;\n  currentImage: ImageMetadata | null;\n  currentImageData: ImageData | null;\n  isLoading: boolean;\n  error: string | null;\n  progress: ProgressStatus | null;\n  annotations: Annotation[];\n  navigateNext: () => Promise<void>;\n  navigatePrevious: () => Promise<void>;\n  navigateToIndex: (index: number) => Promise<void>;\n  markImageComplete: (imageId: string) => Promise<void>;\n  saveCurrentAnnotations: (annotations: Annotation[]) => Promise<void>;\n  updateAnnotations: (annotations: Annotation[]) => void;\n  refreshImageList: () => Promise<void>;\n}\n\nconst ImageNavigationContext = createContext<ImageNavigationContextType | undefined>(undefined);\n\ninterface ImageNavigationProviderProps {\n  children: ReactNode;\n}\n\nexport const ImageNavigationProvider: React.FC<ImageNavigationProviderProps> = ({ children }) => {\n  const [images, setImages] = useState<ImageMetadata[]>([]);\n  const [currentImageIndex, setCurrentImageIndex] = useState<number>(0);\n  const [currentImageData, setCurrentImageData] = useState<ImageData | null>(null);\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [progress, setProgress] = useState<ProgressStatus | null>(null);\n  const [annotations, setAnnotations] = useState<Annotation[]>([]);\n\n  const currentImage = images[currentImageIndex] || null;\n\n  // Initialize: Load image list and progress\n  useEffect(() => {\n    initializeImageNavigation();\n  }, []);\n\n  // Load annotations when current image changes\n  useEffect(() => {\n    if (currentImage) {\n      loadCurrentImageData();\n    }\n  }, [currentImage]);\n\n  const initializeImageNavigation = async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Load image list\n      const imageList = await imageService.fetchImageList();\n      setImages(imageList);\n\n      // Load progress to determine starting index\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n      \n      const startIndex = Math.min(progressData.currentImageIndex, Math.max(0, imageList.length - 1));\n      setCurrentImageIndex(startIndex);\n\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to initialize image navigation');\n      console.error('Error initializing image navigation:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadCurrentImageData = async () => {\n    if (!currentImage) {\n      setCurrentImageData(null);\n      setAnnotations([]);\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Load annotations for current image\n      const imageAnnotations = await imageService.fetchImageAnnotations(currentImage.id);\n      setAnnotations(imageAnnotations);\n\n      // Create ImageData object for compatibility with existing components\n      const imageData: ImageData = {\n        id: currentImage.id,\n        filename: currentImage.filename,\n        url: currentImage.url,\n        width: currentImage.width,\n        height: currentImage.height,\n        annotations: imageAnnotations,\n        uploadedAt: currentImage.lastModified,\n      };\n\n      setCurrentImageData(imageData);\n\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to load image data');\n      console.error('Error loading image data:', err);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const navigateNext = async () => {\n    if (currentImageIndex < images.length - 1) {\n      await navigateToIndex(currentImageIndex + 1);\n    }\n  };\n\n  const navigatePrevious = async () => {\n    if (currentImageIndex > 0) {\n      await navigateToIndex(currentImageIndex - 1);\n    }\n  };\n\n  const navigateToIndex = async (index: number) => {\n    if (index < 0 || index >= images.length) {\n      return;\n    }\n\n    // Save current annotations before navigation\n    if (currentImage && annotations.length > 0) {\n      await saveCurrentAnnotations(annotations);\n    }\n\n    // Update progress index on backend\n    try {\n      await imageService.updateProgressIndex(index);\n    } catch (err) {\n      console.warn('Failed to update progress index:', err);\n    }\n\n    setCurrentImageIndex(index);\n\n    // Refresh progress data\n    try {\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n    } catch (err) {\n      console.warn('Failed to refresh progress:', err);\n    }\n  };\n\n  const markImageComplete = async (imageId: string) => {\n    try {\n      // Update the image's completion status locally\n      setImages(prevImages => \n        prevImages.map(img => \n          img.id === imageId \n            ? { ...img, isCompleted: true, annotationCount: annotations.length }\n            : img\n        )\n      );\n\n      // Refresh progress data\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n\n    } catch (err) {\n      console.error('Error marking image complete:', err);\n    }\n  };\n\n  const saveCurrentAnnotations = async (annotationsToSave: Annotation[]) => {\n    if (!currentImage) return;\n\n    try {\n      await imageService.saveImageAnnotations(currentImage.id, annotationsToSave);\n      \n      // Update local state\n      setAnnotations(annotationsToSave);\n      \n      // Mark image as complete if it has annotations\n      if (annotationsToSave.length > 0) {\n        await markImageComplete(currentImage.id);\n      }\n\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to save annotations');\n      console.error('Error saving annotations:', err);\n    }\n  };\n\n  const updateAnnotations = (newAnnotations: Annotation[]) => {\n    setAnnotations(newAnnotations);\n  };\n\n  const refreshImageList = async () => {\n    try {\n      const imageList = await imageService.fetchImageList();\n      setImages(imageList);\n\n      const progressData = await imageService.fetchLabelingProgress();\n      setProgress(progressData);\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to refresh image list');\n    }\n  };\n\n  const contextValue: ImageNavigationContextType = {\n    images,\n    currentImageIndex,\n    currentImage,\n    currentImageData,\n    isLoading,\n    error,\n    progress,\n    annotations,\n    navigateNext,\n    navigatePrevious,\n    navigateToIndex,\n    markImageComplete,\n    saveCurrentAnnotations,\n    updateAnnotations,\n    refreshImageList,\n  };\n\n  return (\n    <ImageNavigationContext.Provider value={contextValue}>\n      {children}\n    </ImageNavigationContext.Provider>\n  );\n};\n\nexport const useImageNavigation = (): ImageNavigationContextType => {\n  const context = useContext(ImageNavigationContext);\n  if (context === undefined) {\n    throw new Error('useImageNavigation must be used within an ImageNavigationProvider');\n  }\n  return context;\n};\n\nexport default ImageNavigationContext; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}